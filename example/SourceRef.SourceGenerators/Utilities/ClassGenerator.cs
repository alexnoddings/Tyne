using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace Tyne.SourceRef.SourceGenerators.Utilities;

internal static class ClassGenerator
{
    /// <summary>
    ///     Generates the <see cref="SourceText"/> of an internal static Tyne.SourceRef class.
    /// </summary>
    public static SourceText GenerateClass(string className, IEnumerable<SourceInfo> sources, Func<SourceInfo, string> fieldFunc)
    {
        // Start building the class header
        var classBuilder = new StringBuilder()
            .AppendLine("// <auto-generated/>")
            .AppendLine("namespace Tyne.SourceRef")
            .AppendLine("{")
            .AppendLine($"    internal static class {className}")
            .AppendLine("    {");

        // Every source info we have is transformed into one field using fieldFunc
        foreach (var sourceInfo in sources.OrderBy(type => type.Identifier))
        {
            var fieldValue = fieldFunc(sourceInfo);

            // Some content starts with a newline which isn't relevant in examples
            if (fieldValue.StartsWith("\\n", StringComparison.Ordinal))
                fieldValue = fieldValue.Substring(2);

            // And some content ends with a newline which isn't relevant in examples
            if (fieldValue.EndsWith("\\n", StringComparison.Ordinal))
                fieldValue = fieldValue.Substring(0, fieldValue.Length - 2);

            // The field name is the source's normalised identifier
            _ = classBuilder.AppendLine($"        public const string {sourceInfo.IdentifierNormalised} = \"{fieldValue}\";");
        }

        var classContents = classBuilder
            .AppendLine("    }")
            .AppendLine("}")
            .ToString();

        return SourceText.From(classContents, Encoding.UTF8);
    }
}
